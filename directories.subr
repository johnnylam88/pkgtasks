# $NetBSD$
#
# Copyright (c) 2017 The NetBSD Foundation, Inc.
# All rights reserved.
#
# This code is derived from software contributed to The NetBSD Foundation
# by Johnny C. Lam.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# NAME
#	directories.subr -- directory management for packages
#
# SYNOPSIS
#	task_directories add | remove | perms
#	task_directories check-add | check-remove | check-perms
#
# DESCRIPTION
#	The task_directories function supports six actions: "add", "remove",
#	"perms", "check-add", "check-remove", and "check-perms".  The
#	function reads standard input line by line and looks for lines of
#	the form:
#
#	    # DIR: <directory> <flags> [<mode> [<user> [<group>]]]
#
#	If directory path is relative, then is are assumed to be relative
#	to ${PKG_PREFIX}.
#
#	The third field in each line is set of flags with the following
#	meaning:
#
#	    m	directory is created (required)
#	    f	ignore ${PKG_CONFIG} value
#	    o	directory is owned by the package
#
#	The "add" action creates the directory and sets the permissions on
#	the directory if given.  A reference count for the directory will
#	be added for the package.
#
#	The "remove" action removes the directory.  A reference count for
#	the directory will be removed for the package.
#
#	The "perms" action sets the mode and permissions on the directory
#	if they are given.
#
#	The "check-add" action will check whether the directory exists or
#	otherwise writes a message to standard output noting the missing
#	directory.
#
#	The "check-remove" action will check whether the directory has
#	been removed or otherwise writes a message to standard output
#	noting the directory still exist.
#
#	The "check-perms" action will check whether the directory has the
#	correct permissions or otherwise writes a message to standard
#	output noting the directory has incorrect permissions.
#
# RETURN VALUES
#	The "add", "remove", and "perms" actions return 0 if they are
#	successful for all directories, and >0 if an error occurs.
#
#	The "check-add", "check-remove", and "check-perms" actions return
#	>0 if they write informative messages, and return 0 otherwise.
#
# ENVIRONMENT
#	The following variables are used if they are set:
#
#	PKGNAME
#		The name of the package.
#
#	PKG_CONFIG
#		If ${PKG_CONFIG} is a "truthy" value, then the "add" and
#		"remove" actions are allowed to make changes to the
#		filesystem as needed.
#
#	PKG_CONFIG_PERMS
#		If ${PKG_CONFIG_PERMS} is a "truthy" value, then the
#		"perms" action is allowed to make changes to the
#		filesystem as needed.
#
#	PKG_DESTDIR
#		A "destdir" prefix that is prepended to all filesystem
#		paths.  The default value is the empty string.
#
#	PKG_PREFIX
#		The installation prefix of the package.  The default is
#		"/usr/pkg".
#
#	RMDIR	The name or path to the rmdir(1) utility.
#

__task_directories__="yes"

task_load echo
task_load makedir
task_load permissions
task_load refcount
task_load truthy

task_directories()
{
	: ${RMDIR:=rmdir}

	: ${PKG_PREFIX:=/usr/pkg}
	: ${PKGNAME:=${0##*/}}

	: ${PKG_CONFIG:=yes}
	: ${PKG_CONFIG_PERMS:=yes}

	local action="$1"; shift
        case $action in
	add|remove|perms)
		task_echo -bc "  > ${PKGNAME}: directories" ;;
	check-add|check-remove|check-perms)
		: "valid actions" ;;
	*)      return 0 ;;
	esac

	# Guard against ${PKG_PREFIX} == "/".
	local prefix
	case ${PKG_PREFIX}/ in
	//)	prefix= ;;
	*)	prefix=${PKG_PREFIX} ;;
	esac

	local pkg_config="yes"
	local pkg_config_perms="yes"
	task_is_truthy "${PKG_CONFIG}" || pkg_config=
	task_is_truthy "${PKG_CONFIG_PERMS}" || pkg_config_perms=

	local result line_result
	local msg
	local owned makedir changes
	local refcount

	result=0
	local d_path
	local hash tag path flags mode user group
	while read hash tag path flags mode user group; do
		# Filter for "# DIR:".
		case $hash/$tag in
		"#/DIR:")
			: "use this line" ;;
		*)	continue ;;
		esac
		case $flags in
		*m*)	: "make flag is required" ;;
		*)	continue ;;
		esac

		# Canonicalize paths.
		case $path in
		"")	# skip lines without any required args
			continue ;;
		[!/]*)	path="$prefix/$path" ;;
		esac
		d_path="${PKG_DESTDIR}$path"

		msg=
		case $mode/$user/$group in
                //)	msg="$d_path" ;;
		[!/]*//)
			msg="$d_path (m=$mode)" ;;
		[!/]*/[!/]*/)
			msg="$d_path (m=$mode, o=$user)" ;;
		[!/]*/[!/]*/[!/]*)
			msg="$d_path (m=$mode, o=$user, g=$group)" ;;
		esac

		# Set owner values if the directory should be owned by this package.
		owned=
		case $flags in
		*o*)	owned="yes"
			if task_refcount prop_exists dirs "$path" owner; then
				# previous owner detected
				if task_refcount prop_match dirs "$path" owner; then
					: "same owner"
				else
					# conflicting owners; failure event
					task_echo "    ! directory owner conflict: $d_path"
					result=1
					continue
				fi
			fi ;;
		esac

		makedir=
		case $flags in
		*f*)	# "f" always implies make.
			makedir="yes" ;;
		*)	# If not "f", then make only if PKG_CONFIG is truthy.
			if [ -n "$pkg_config" ]; then
			   	makedir="yes"
			fi ;;
		esac

		line_result=0
		changes=
		case $action in
		add)	refcount="yes"
			task_refcount exists dirs "$path" || refcount=
			if task_refcount add dirs "$path"; then
				if [ -d "$d_path" ]; then
					# Directory already exists.
					if [ -z "$refcount" ]; then
						task_refcount prop_put dirs "$path" preexist || line_result=1
					fi
					task_echo "    ! directory already exists: $d_path"
				elif [ -z "$makedir" ]; then
					task_echo "    ! directory creation skipped: $d_path"
				elif task_makedir "$d_path"; then
					task_echo "    > directory created: $d_path"
					changes="$changes create"
				else
					task_echo "    ! directory not created: $d_path"
					line_result=1
				fi
				if [ $line_result -eq 0 -a -n "$owned" ]; then
					# Directory is owned by this package.
					if task_refcount prop_put dirs "$path" owner; then
						task_echo "    > directory is owned by ${PKGNAME}: $path"
					else
						line_result=1
					fi
				fi
			else
				# add refcount failed; skip to next line
				task_echo "    ! refcount add failure: directories $path"
				result=1
				continue
			fi ;;
		check-add)
			if [ -d "$d_path" ]; then
				: "directory already exists"
			else
				task_echo "!!! INFO: ${PKGNAME}: Create directory: $msg"
				line_result=1
			fi ;;
		esac
		if [ $line_result -eq 0 ]; then
			case $mode/$user/$group in
			//)	: "no permissions to set" ;;
			*)	case $action in
				add|perms)
					task_refcount prop_put dirs "$path" permissions "$mode" "$user" "$group" || line_result=1
					if [ ! -d "$d_path" ]; then
						task_echo "    ! directory permissions not set on missing: $msg"
						line_result=1
					elif [ -z "$pkg_config_perms" ]; then
						task_echo "    ! directory permissions skipped: $msg"
					elif task_set_permissions "$d_path" "$mode" "$user" "$group"; then
						task_echo "    > directory permissions set: $msg"
					else
						task_echo "    ! directory permissions not set: $msg"
						line_result=1
					fi ;;
				check-add|check-perms)
					if [ -d "$d_path" ] &&
					   task_check_permissions "$d_path" "$mode" "$user" "$group"; then
					   	: "directory has correct permissions"
					else
					   	task_echo "!!! INFO: ${PKGNAME}: Set directory permissions: $msg"
						line_result=1
					fi
				esac ;;
			esac
		fi
		if [ $line_result -eq 0 ]; then
			case $action in
			remove)	if task_refcount remove dirs "$path"; then
					if task_refcount exists dirs "$path"; then
						# refcount is not zero
						if [ -n "$owned" ]; then
							# owned directory has existing references; failure event.
							task_echo "    ! directory owned but references exist: $path"
							line_result=1
						fi
					else
						# no more references
						if task_refcount prop_exists dirs "$path" preexist; then
							: "directory is preexisting"
						elif [ ! -d "$d_path" ]; then
							: "directory already removed"
						elif [ -n "$makedir" ]; then
							${RMDIR} -p "$d_path" 2>/dev/null
						fi	
						# Only warn if the directory is owned by the package.
						if [ -n "$owned" ]; then
							if [ -d "$d_path" ]; then
								task_echo "    ! directory not removed: $d_path"
							else
								task_echo "    > directory removed: $d_path"
							fi
						fi
						# delete the reference count
						task_refcount delete dirs "$path"
					fi
				else
					# remove refcount failed
					task_echo "    ! refcount remove failure: directories $path"
					line_result=1
				fi ;;
			check-remove)
				if task_refcount exists dirs "$path"; then
					: "refcount is not zero"
				elif [ ! -d "$d_path" ]; then
					: "directory already removed"
				elif [ -n "$owned" ]; then
					# Only warn if the directory is owned by the package.
					task_echo "!!! INFO: ${PKGNAME}: Remove directory: $d_path"
					line_result=1
				fi
			esac
		fi
		if [ $line_result -gt 0 ]; then
			# Undo changes if there was an error.
			case " $changes " in
			*" create "*)
				${RMDIR} -p "$d_path" 2>/dev/null ;;
			esac
		fi
		[ $line_result -eq 0 ] || result=1
	done
	return $result
}
